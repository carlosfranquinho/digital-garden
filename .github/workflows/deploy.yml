name: Process and Deploy Digital Garden

on:
  repository_dispatch:
    types: [obsidian-update]

jobs:
  process-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: 🚀 Checkout Digital Garden
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GARDEN_TOKEN }}

      - name: 📅 Receber Conteúdo
        id: payload
        run: |
          echo '${{ toJSON(github.event.client_payload.notas) }}' > /tmp/notas.json
          echo "📌 Conteúdo recebido:"
          cat /tmp/notas.json

      - name: 🧹 Limpar Diretórios
        run: |
          rm -rf content/notas/*
          rm -rf static/imagens/*
          mkdir -p content/notas static/imagens

      - name: 📂 Importar Notas e Imagens com conversão
        run: |
          sudo apt update && sudo apt install -y python3-pip
          pip install pillow python-slugify

          cat << 'EOF' > processar.py
          import os, json, re, shutil
          from pathlib import Path
          from slugify import slugify
          from PIL import Image

          VAULT = Path("/tmp/obsidian-vault")
          DEST_NOTAS = Path("content/notas")
          DEST_IMGS = Path("static/imagens")

          with open("/tmp/notas.json", "r") as f:
              paths = json.load(f)

          img_count = {}

          def format_link(link_text):
              link_text = link_text.strip().strip('"').strip("'")
              if '|' in link_text:
                  target, alias = link_text.split('|', 1)
              else:
                  target = alias = link_text
              slug = slugify(target)
              return f"[{alias.strip()}](/notas/{slug})"

          def corrigir_links(conteudo):
              return re.sub(r'\[\[(.+?)\]\]', lambda m: format_link(m.group(1)), conteudo)

          def gerar_nome_imagem(slug, n):
              return f"{slug}-{n}.webp"

          for path in paths:
              origem = VAULT / path

              if path.endswith(".md"):
                  nome_base = Path(path).stem
                  slug = slugify(nome_base)
                  img_count[slug] = 1

                  conteudo = origem.read_text(encoding="utf-8")

                  def substituir(match):
                      nome_img = match.group(1).strip()
                      # Esperamos que a imagem já tenha sido incluída em paths — por isso, confiamos que existe com caminho correto
                      for img_path in paths:
                          if img_path.endswith(nome_img):
                              origem_img = VAULT / img_path
                              break
                      else:
                          return ""  # Imagem não encontrada

                      n = img_count[slug]
                      novo_nome = gerar_nome_imagem(slug, n)
                      destino_img = DEST_IMGS / novo_nome

                      ext = origem_img.suffix.lower()
                      if ext == ".webp":
                          shutil.copy2(origem_img, destino_img)
                      else:
                          with Image.open(origem_img) as img:
                              if img.width > 1200:
                                  ratio = 1200 / img.width
                                  img = img.resize((1200, int(img.height * ratio)))
                              img.save(destino_img, "webp", quality=85)

                      img_count[slug] += 1
                      return f'{{{{< taped src="/imagens/{novo_nome}" alt="{slug}" >}}}}'

                  conteudo = re.sub(r'!\[\[([^\]]+)\]\]', substituir, conteudo)
                  conteudo = corrigir_links(conteudo)

                  destino = DEST_NOTAS / f"{slug}.md"
                  destino.write_text(conteudo, encoding="utf-8")

              elif any(path.lower().endswith(ext) for ext in [".png", ".jpg", ".jpeg", ".webp"]):
                  # Este bloco só será usado para garantir que imagens extra são incluídas mesmo sem serem chamadas nas notas
                  origem_img = origem
                  slug = slugify(Path(path).parts[0])  # usa o diretório da imagem como base do slug
                  n = img_count.get(slug, 1)
                  novo_nome = gerar_nome_imagem(slug, n)
                  destino_img = DEST_IMGS / novo_nome

                  ext = origem_img.suffix.lower()
                  if ext == ".webp":
                      shutil.copy2(origem_img, destino_img)
                  else:
                      with Image.open(origem_img) as img:
                          if img.width > 1200:
                              ratio = 1200 / img.width
                              img = img.resize((1200, int(img.height * ratio)))
                          img.save(destino_img, "webp", quality=85)

                  img_count[slug] = n + 1
          EOF

          git clone https://${{ github.actor }}:${{ secrets.GARDEN_TOKEN }}@github.com/${{ github.repository_owner }}/obsidian-vault.git /tmp/obsidian-vault
          python3 processar.py

      - name: 🛠️ Instalar Hugo
        uses: peaceiris/actions-hugo@v2
        with:
          hugo-version: 'latest'
          extended: true

      - name: 📦 Gerar Site
        run: hugo --minify

      - name: 📡 FTP Deploy
        uses: SamKirkland/FTP-Deploy-Action@v4.3.4
        with:
          server: ${{ secrets.FTP_SERVER }}
          username: ${{ secrets.FTP_USERNAME }}
          password: ${{ secrets.FTP_PASSWORD }}
          server-dir: ${{ secrets.FTP_PATH }}
          local-dir: public/

      - name: 🔄 Commitar Mudanças
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          git add content/notas static/imagens
          git diff --quiet && git diff --staged --quiet || git commit -m "Atualização automática: conteúdo do Obsidian [skip ci]"
          git push
